import * as react_jsx_runtime from 'react/jsx-runtime';
import { ComponentType, FC } from 'react';

type ProgressData = {
    id: string;
    total: number;
    current: number;
};
type AgentEventData = {
    agent: string;
    text: string;
    type: 'text' | 'progress';
    data?: ProgressData;
};
declare function ChatAgentEvents({ data, isFinished, isLast, }: {
    data: AgentEventData[];
    isFinished: boolean;
    isLast: boolean;
}): react_jsx_runtime.JSX.Element;

type EventData = {
    title: string;
};
declare function ChatEvents({ data, showLoading, }: {
    data: EventData[];
    showLoading: boolean;
}): react_jsx_runtime.JSX.Element;

type DocumentFile = {
    id: string;
    name: string;
    size: number;
    type: string;
    url: string;
    refs?: string[];
};
type SourceNode = {
    id: string;
    metadata: Record<string, unknown>;
    score?: number;
    text: string;
    url?: string;
};
type Document = {
    url: string;
    sources: SourceNode[];
};
declare function DocumentInfo({ document, className, onRemove, startIndex, }: {
    document: Document;
    className?: string;
    onRemove?: () => void;
    startIndex?: number;
}): react_jsx_runtime.JSX.Element;

type DocumentFileData = {
    files: DocumentFile[];
};
declare function ChatFiles({ data, className, }: {
    data: DocumentFileData;
    className?: string;
}): react_jsx_runtime.JSX.Element | null;

type ImageData = {
    url: string;
};
declare function ChatImage({ data }: {
    data: ImageData;
}): react_jsx_runtime.JSX.Element;

type SourceData = {
    nodes: SourceNode[];
};
declare function ChatSources({ data }: {
    data: SourceData;
}): react_jsx_runtime.JSX.Element | null;

interface CitationComponentProps {
    index: number;
    node: SourceNode;
}
declare function Citation({ index }: CitationComponentProps): react_jsx_runtime.JSX.Element;

interface LanguageRendererProps {
    code: string;
    className?: string;
}
declare function Markdown({ content, sources, backend, citationComponent: CitationComponent, className: customClassName, languageRenderers, annotationRenderers, }: {
    content: string;
    sources?: SourceData;
    backend?: string;
    citationComponent?: ComponentType<CitationComponentProps>;
    className?: string;
    languageRenderers?: Record<string, ComponentType<LanguageRendererProps>>;
    annotationRenderers?: Record<string, ComponentType<{
        data: any;
    }>>;
}): react_jsx_runtime.JSX.Element;

interface Props {
    language: string;
    value: string;
    className?: string;
    showHeader?: boolean;
    headerClassName?: string;
    codeClassName?: string;
}
interface languageMap {
    [key: string]: string | undefined;
}
declare const programmingLanguages: languageMap;
declare const generateRandomString: (length: number, lowercase?: boolean) => string;
declare const CodeBlock: FC<Props>;

interface PdfDialogProps {
    documentId: string;
    url: string;
    trigger: React.ReactNode;
}
declare function PdfDialog(props: PdfDialogProps): react_jsx_runtime.JSX.Element;

type MessageRole = 'system' | 'user' | 'assistant' | 'data';
type JSONValue = null | string | number | boolean | {
    [value: string]: JSONValue;
} | JSONValue[];
interface Message {
    content: string;
    role: MessageRole;
    annotations?: JSONValue[];
}
type ChatHandler = {
    input: string;
    setInput: (input: string) => void;
    isLoading: boolean;
    messages: Message[];
    reload?: (chatRequestOptions?: {
        data?: any;
    }) => void;
    stop?: () => void;
    append: (message: Message, chatRequestOptions?: {
        data?: any;
    }) => Promise<string | null | undefined>;
    setMessages?: (messages: (Message & {
        id: string;
    })[]) => void;
};

type SuggestedQuestionsData = string[];
declare function SuggestedQuestions({ questions, append, requestData, }: {
    questions: SuggestedQuestionsData;
    append: ChatHandler['append'];
    requestData?: any;
}): false | react_jsx_runtime.JSX.Element;

interface StarterQuestionsProps {
    questions: string[];
    append: ChatHandler['append'];
    className?: string;
}
declare function StarterQuestions(props: StarterQuestionsProps): react_jsx_runtime.JSX.Element;

declare function ImagePreview({ url, onRemove, }: {
    url: string;
    onRemove: () => void;
}): react_jsx_runtime.JSX.Element;

interface FileUploaderProps {
    config?: {
        inputId?: string;
        fileSizeLimit?: number;
        allowedExtensions?: string[];
        disabled: boolean;
        multiple?: boolean;
    };
    onFileUpload: (file: File) => Promise<void>;
    onFileError?: (errMsg: string) => void;
    className?: string;
}
declare function FileUploader({ config, onFileUpload, onFileError, className, }: FileUploaderProps): react_jsx_runtime.JSX.Element;

type CodeEditorLanguage = 'javascript' | 'python' | 'html' | 'css';
declare function CodeEditor({ code, onChange, className, language, }: {
    code: string;
    onChange?: (code: string) => void;
    className?: string;
    language?: 'javascript' | 'python' | 'html' | 'css';
}): react_jsx_runtime.JSX.Element;
declare function fileExtensionToEditorLang(extension: string): CodeEditorLanguage | undefined;

declare function DocumentEditor({ content, onChange, className, showToolbar, }: {
    content: string;
    onChange?: (markdown: string) => void;
    className?: string;
    showToolbar?: boolean;
}): react_jsx_runtime.JSX.Element;

export { ChatAgentEvents, ChatEvents, ChatFiles, ChatImage, ChatSources, Citation, CodeBlock, CodeEditor, DocumentEditor, DocumentInfo, FileUploader, ImagePreview, Markdown, PdfDialog, StarterQuestions, SuggestedQuestions, fileExtensionToEditorLang, generateRandomString, programmingLanguages };
export type { AgentEventData, CitationComponentProps, Document, DocumentFile, DocumentFileData, EventData, FileUploaderProps, ImageData, LanguageRendererProps, PdfDialogProps, ProgressData, SourceData, SourceNode, SuggestedQuestionsData };
