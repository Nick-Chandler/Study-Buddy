'use client';
import { remark } from 'remark';
import remarkParse from 'remark-parse';
import { visit } from 'unist-util-visit';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { History, Check, Copy, Download, X } from 'lucide-react';
import * as React from 'react';
import { useState } from 'react';
import { u as useCopyToClipboard } from './use-copy-to-clipboard-12s-B94o_fsN.js';
import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
import { B as Badge } from './badge-12s-jRdj-BxT.js';
import { _ as _$1 } from '@swc/helpers/_/_extends';
import { _ } from '@swc/helpers/_/_object_without_properties_loose';
import { Slot } from '@radix-ui/react-slot';
import { cva } from 'class-variance-authority';
import { P as Popover, a as PopoverTrigger, b as PopoverContent } from './popover-12s-DoMcXcZu.js';
import { u as useChatCanvas } from './context-12s-DUrdLaCB.js';

var MessageAnnotationType = /*#__PURE__*/ function(MessageAnnotationType) {
    MessageAnnotationType["IMAGE"] = "image";
    MessageAnnotationType["DOCUMENT_FILE"] = "document_file";
    MessageAnnotationType["SOURCES"] = "sources";
    MessageAnnotationType["EVENTS"] = "events";
    MessageAnnotationType["SUGGESTED_QUESTIONS"] = "suggested_questions";
    MessageAnnotationType["AGENT_EVENTS"] = "agent";
    MessageAnnotationType["ARTIFACT"] = "artifact";
    return MessageAnnotationType;
}({});
function isMessageAnnotation(annotation) {
    return annotation !== null && typeof annotation === 'object' && 'type' in annotation && 'data' in annotation && typeof annotation.type === 'string';
}

const INLINE_ANNOTATION_KEY = 'annotation';
// parse Markdown and extract code blocks
function parseMarkdownCodeBlocks(markdown) {
    const markdownCodeBlocks = [];
    // Parse Markdown to AST using remark
    const processor = remark().use(remarkParse);
    const ast = processor.parse(markdown);
    // Visit all code nodes in the AST
    visit(ast, 'code', (node)=>{
        markdownCodeBlocks.push({
            language: node.lang || null,
            code: node.value
        });
    });
    return markdownCodeBlocks;
}
// extract all inline annotations from markdown
function getInlineAnnotations(message) {
    const codeBlocks = parseMarkdownCodeBlocks(message.content);
    return codeBlocks.filter((block)=>block.language === INLINE_ANNOTATION_KEY).map((block)=>tryParse(block.code)).filter(Boolean) // filter out null values
    ;
}
// convert annotation to inline markdown
function toInlineAnnotation(annotation) {
    return `\`\`\`${INLINE_ANNOTATION_KEY}\n${JSON.stringify(annotation)}\n\`\`\``;
}
/**
 * Parses and validates an inline annotation from a code block
 * @param language - The language identifier from the markdown code block
 * @param codeValue - The raw code content from a markdown code block
 * @returns The parsed annotation if valid, null if not an annotation or invalid
 */ function parseInlineAnnotation(language, codeValue) {
    // Check if this is an inline annotation code block
    if (language !== INLINE_ANNOTATION_KEY) {
        return null;
    }
    try {
        const annotation = tryParse(codeValue);
        if (annotation === null || !isMessageAnnotation(annotation)) {
            console.warn(`Invalid inline annotation: ${codeValue}, expected an object`);
            return null;
        }
        return annotation;
    } catch (error) {
        console.warn(`Failed to parse inline annotation: ${codeValue}`, error);
        return null;
    }
}
// try to parse the code value as a JSON object and return null if it fails
function tryParse(codeValue) {
    try {
        return JSON.parse(codeValue);
    } catch (error) {
        return null;
    }
}

/**
 * Gets annotation data directly from a message by type
 * @param message - The message to extract annotations from
 * @param type - The annotation type to filter by (can be standard or custom)
 * @returns Array of data from annotations of the specified type, or null if none found
 */ function getVercelAnnotations(message) {
    var _message_annotations;
    return (_message_annotations = message.annotations) != null ? _message_annotations : [];
}

/**
 * Gets all annotation data from a message by type, combining results from multiple parsers
 * @param message - The message to extract annotations from
 * @param type - The annotation type to filter by (can be standard or custom)
 * @param parsers - Array of parser functions to use (defaults to Vercel and inline parsers)
 * @returns Array of data from annotations of the specified type from all parsers
 */ function getAnnotationData(message, type, parsers = [
    getVercelAnnotations,
    getInlineAnnotations
]) {
    const allAnnotations = parsers.flatMap((parser)=>parser(message)).filter((a)=>isMessageAnnotation(a));
    return allAnnotations.filter((a)=>a.type === type).map((a)=>a.data);
}

// check if two artifacts are equal by comparing their type and created time
function isEqualArtifact(a, b) {
    return a.type === b.type && a.created_at === b.created_at;
}
// extract artifacts from all messages (sort ascending by created_at)
function extractArtifactsFromAllMessages(messages) {
    return messages.flatMap(extractArtifactsFromMessage).sort((a, b)=>a.created_at - b.created_at);
}
function extractArtifactsFromMessage(message) {
    return getAnnotationData(message, MessageAnnotationType.ARTIFACT, [
        getInlineAnnotations
    ]);
}

function cn(...inputs) {
    return twMerge(clsx(inputs));
}

const buttonVariants = cva('inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50', {
    variants: {
        variant: {
            default: 'bg-primary text-primary-foreground hover:bg-primary/90',
            destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
            outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
            secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
            ghost: 'hover:bg-accent hover:text-accent-foreground',
            link: 'text-primary underline-offset-4 hover:underline'
        },
        size: {
            default: 'h-10 px-4 py-2',
            sm: 'h-9 rounded-md px-3',
            lg: 'h-11 rounded-md px-8',
            icon: 'h-10 w-10'
        }
    },
    defaultVariants: {
        variant: 'default',
        size: 'default'
    }
});
const Button = /*#__PURE__*/ React.forwardRef((_param, ref)=>{
    var { className, variant, size, asChild = false } = _param, props = _(_param, [
        "className",
        "variant",
        "size",
        "asChild"
    ]);
    const Comp = asChild ? Slot : 'button';
    return /*#__PURE__*/ jsx(Comp, _$1({
        className: cn(buttonVariants({
            variant,
            size,
            className
        })),
        ref: ref
    }, props));
});
Button.displayName = 'Button';

function ChatCanvasActions(props) {
    var _props_children;
    const children = (_props_children = props.children) != null ? _props_children : /*#__PURE__*/ jsxs(Fragment, {
        children: [
            /*#__PURE__*/ jsx(ArtifactVersionHistory, {}),
            /*#__PURE__*/ jsx(ArtifactContentCopy, {}),
            /*#__PURE__*/ jsx(ArtifactDownloadButton, {}),
            /*#__PURE__*/ jsx(CanvasCloseButton, {})
        ]
    });
    return /*#__PURE__*/ jsx("div", {
        className: cn('flex items-center gap-1', props.className),
        children: children
    });
}
function ArtifactVersionHistory() {
    const { getArtifactsByType, openArtifactInCanvas, displayedArtifact, getArtifactVersion, restoreArtifact } = useChatCanvas();
    const [isOpen, setIsOpen] = useState(false);
    if (!displayedArtifact) return null;
    const allArtifactsByCurrentType = getArtifactsByType(displayedArtifact.type);
    return /*#__PURE__*/ jsxs(Popover, {
        open: isOpen,
        onOpenChange: setIsOpen,
        children: [
            /*#__PURE__*/ jsx(PopoverTrigger, {
                asChild: true,
                children: /*#__PURE__*/ jsxs(Button, {
                    variant: "secondary",
                    className: "h-8 cursor-pointer rounded-full text-xs",
                    children: [
                        /*#__PURE__*/ jsx(History, {
                            className: "mr-1 size-4"
                        }),
                        "Version ",
                        getArtifactVersion(displayedArtifact).versionNumber
                    ]
                })
            }),
            /*#__PURE__*/ jsxs(PopoverContent, {
                className: "w-48 p-0 text-xs",
                align: "end",
                children: [
                    /*#__PURE__*/ jsx("h4", {
                        className: "border-b p-2 px-3 font-semibold",
                        children: "Version History"
                    }),
                    /*#__PURE__*/ jsx("div", {
                        className: "max-h-80 overflow-y-auto",
                        children: allArtifactsByCurrentType.map((artifact, index)=>{
                            const isCurrent = isEqualArtifact(artifact, displayedArtifact);
                            const { versionNumber, isLatest } = getArtifactVersion(artifact);
                            return /*#__PURE__*/ jsxs("div", {
                                className: "text-muted-foreground flex cursor-pointer items-center justify-between px-3 py-2 hover:bg-gray-100",
                                onClick: ()=>{
                                    openArtifactInCanvas(artifact);
                                    setIsOpen(false);
                                },
                                children: [
                                    /*#__PURE__*/ jsxs("span", {
                                        className: cn(isCurrent && 'text-blue-500'),
                                        children: [
                                            "Version ",
                                            versionNumber
                                        ]
                                    }),
                                    isLatest ? /*#__PURE__*/ jsx(Badge, {
                                        className: "h-6 w-[70px] justify-center bg-blue-500 text-center hover:bg-blue-600",
                                        children: "Latest"
                                    }) : /*#__PURE__*/ jsx(Button, {
                                        variant: "outline",
                                        size: "sm",
                                        className: "h-6 w-[70px] shrink-0 cursor-pointer rounded-full text-xs",
                                        onClick: (e)=>{
                                            e.stopPropagation();
                                            restoreArtifact(artifact);
                                            setIsOpen(false);
                                        },
                                        children: "Restore"
                                    })
                                ]
                            }, index);
                        })
                    })
                ]
            })
        ]
    });
}
function ArtifactContentCopy() {
    const { isCopied, copyToClipboard } = useCopyToClipboard({
        timeout: 1000
    });
    const { displayedArtifact } = useChatCanvas();
    if (!displayedArtifact) return null;
    const content = getArtifactContent(displayedArtifact);
    if (!content) return null;
    const handleCopy = ()=>{
        if (isCopied) return;
        copyToClipboard(content);
    };
    return /*#__PURE__*/ jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: handleCopy,
        children: isCopied ? /*#__PURE__*/ jsx(Check, {
            className: "size-4"
        }) : /*#__PURE__*/ jsx(Copy, {
            className: "size-4"
        })
    });
}
function getArtifactContent(artifact) {
    if (artifact.type === 'code') {
        return artifact.data.code;
    }
    if (artifact.type === 'document') {
        return artifact.data.content;
    }
    return null;
}
function ArtifactDownloadButton() {
    const { displayedArtifact } = useChatCanvas();
    if (!displayedArtifact) return null;
    const content = getArtifactContent(displayedArtifact);
    const fileName = getArtifactDownloadFileName(displayedArtifact);
    if (!content || !fileName) return null;
    const handleDownload = ()=>{
        const blob = new Blob([
            content
        ], {
            type: 'text/plain'
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };
    return /*#__PURE__*/ jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: handleDownload,
        children: /*#__PURE__*/ jsx(Download, {
            className: "size-4"
        })
    });
}
function getArtifactDownloadFileName(artifact) {
    if (artifact.type === 'code') {
        return artifact.data.file_name;
    }
    if (artifact.type === 'document') {
        return artifact.data.title;
    }
    return null;
}
function CanvasCloseButton() {
    const { closeCanvas } = useChatCanvas();
    return /*#__PURE__*/ jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: closeCanvas,
        children: /*#__PURE__*/ jsx(X, {
            className: "size-4"
        })
    });
}
ChatCanvasActions.History = ArtifactVersionHistory;
ChatCanvasActions.Copy = ArtifactContentCopy;
ChatCanvasActions.Download = ArtifactDownloadButton;
ChatCanvasActions.Close = CanvasCloseButton;

export { Button as B, ChatCanvasActions as C, MessageAnnotationType as M, extractArtifactsFromMessage as a, isMessageAnnotation as b, cn as c, getInlineAnnotations as d, extractArtifactsFromAllMessages as e, getAnnotationData as g, isEqualArtifact as i, parseInlineAnnotation as p, toInlineAnnotation as t };
