'use client';
var remark = require('remark');
var remarkParse = require('remark-parse');
var unistUtilVisit = require('unist-util-visit');
var jsxRuntime = require('react/jsx-runtime');
var lucideReact = require('lucide-react');
var React = require('react');
var useCopyToClipboard12s = require('./use-copy-to-clipboard-12s-B5vuZcRz.cjs');
var clsx = require('clsx');
var tailwindMerge = require('tailwind-merge');
var badge12s = require('./badge-12s-DSyu4bRQ.cjs');
var _extends = require('@swc/helpers/_/_extends');
var _object_without_properties_loose = require('@swc/helpers/_/_object_without_properties_loose');
var reactSlot = require('@radix-ui/react-slot');
var classVarianceAuthority = require('class-variance-authority');
var popover12s = require('./popover-12s-BeXNPp2P.cjs');
var context12s = require('./context-12s-Bd_RtAfM.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var remarkParse__default = /*#__PURE__*/_interopDefault(remarkParse);
var React__namespace = /*#__PURE__*/_interopNamespace(React);

var MessageAnnotationType = /*#__PURE__*/ function(MessageAnnotationType) {
    MessageAnnotationType["IMAGE"] = "image";
    MessageAnnotationType["DOCUMENT_FILE"] = "document_file";
    MessageAnnotationType["SOURCES"] = "sources";
    MessageAnnotationType["EVENTS"] = "events";
    MessageAnnotationType["SUGGESTED_QUESTIONS"] = "suggested_questions";
    MessageAnnotationType["AGENT_EVENTS"] = "agent";
    MessageAnnotationType["ARTIFACT"] = "artifact";
    return MessageAnnotationType;
}({});
function isMessageAnnotation(annotation) {
    return annotation !== null && typeof annotation === 'object' && 'type' in annotation && 'data' in annotation && typeof annotation.type === 'string';
}

const INLINE_ANNOTATION_KEY = 'annotation';
// parse Markdown and extract code blocks
function parseMarkdownCodeBlocks(markdown) {
    const markdownCodeBlocks = [];
    // Parse Markdown to AST using remark
    const processor = remark.remark().use(remarkParse__default.default);
    const ast = processor.parse(markdown);
    // Visit all code nodes in the AST
    unistUtilVisit.visit(ast, 'code', (node)=>{
        markdownCodeBlocks.push({
            language: node.lang || null,
            code: node.value
        });
    });
    return markdownCodeBlocks;
}
// extract all inline annotations from markdown
function getInlineAnnotations(message) {
    const codeBlocks = parseMarkdownCodeBlocks(message.content);
    return codeBlocks.filter((block)=>block.language === INLINE_ANNOTATION_KEY).map((block)=>tryParse(block.code)).filter(Boolean) // filter out null values
    ;
}
// convert annotation to inline markdown
function toInlineAnnotation(annotation) {
    return `\`\`\`${INLINE_ANNOTATION_KEY}\n${JSON.stringify(annotation)}\n\`\`\``;
}
/**
 * Parses and validates an inline annotation from a code block
 * @param language - The language identifier from the markdown code block
 * @param codeValue - The raw code content from a markdown code block
 * @returns The parsed annotation if valid, null if not an annotation or invalid
 */ function parseInlineAnnotation(language, codeValue) {
    // Check if this is an inline annotation code block
    if (language !== INLINE_ANNOTATION_KEY) {
        return null;
    }
    try {
        const annotation = tryParse(codeValue);
        if (annotation === null || !isMessageAnnotation(annotation)) {
            console.warn(`Invalid inline annotation: ${codeValue}, expected an object`);
            return null;
        }
        return annotation;
    } catch (error) {
        console.warn(`Failed to parse inline annotation: ${codeValue}`, error);
        return null;
    }
}
// try to parse the code value as a JSON object and return null if it fails
function tryParse(codeValue) {
    try {
        return JSON.parse(codeValue);
    } catch (error) {
        return null;
    }
}

/**
 * Gets annotation data directly from a message by type
 * @param message - The message to extract annotations from
 * @param type - The annotation type to filter by (can be standard or custom)
 * @returns Array of data from annotations of the specified type, or null if none found
 */ function getVercelAnnotations(message) {
    var _message_annotations;
    return (_message_annotations = message.annotations) != null ? _message_annotations : [];
}

/**
 * Gets all annotation data from a message by type, combining results from multiple parsers
 * @param message - The message to extract annotations from
 * @param type - The annotation type to filter by (can be standard or custom)
 * @param parsers - Array of parser functions to use (defaults to Vercel and inline parsers)
 * @returns Array of data from annotations of the specified type from all parsers
 */ function getAnnotationData(message, type, parsers = [
    getVercelAnnotations,
    getInlineAnnotations
]) {
    const allAnnotations = parsers.flatMap((parser)=>parser(message)).filter((a)=>isMessageAnnotation(a));
    return allAnnotations.filter((a)=>a.type === type).map((a)=>a.data);
}

// check if two artifacts are equal by comparing their type and created time
function isEqualArtifact(a, b) {
    return a.type === b.type && a.created_at === b.created_at;
}
// extract artifacts from all messages (sort ascending by created_at)
function extractArtifactsFromAllMessages(messages) {
    return messages.flatMap(extractArtifactsFromMessage).sort((a, b)=>a.created_at - b.created_at);
}
function extractArtifactsFromMessage(message) {
    return getAnnotationData(message, MessageAnnotationType.ARTIFACT, [
        getInlineAnnotations
    ]);
}

function cn(...inputs) {
    return tailwindMerge.twMerge(clsx.clsx(inputs));
}

const buttonVariants = classVarianceAuthority.cva('inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50', {
    variants: {
        variant: {
            default: 'bg-primary text-primary-foreground hover:bg-primary/90',
            destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
            outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
            secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
            ghost: 'hover:bg-accent hover:text-accent-foreground',
            link: 'text-primary underline-offset-4 hover:underline'
        },
        size: {
            default: 'h-10 px-4 py-2',
            sm: 'h-9 rounded-md px-3',
            lg: 'h-11 rounded-md px-8',
            icon: 'h-10 w-10'
        }
    },
    defaultVariants: {
        variant: 'default',
        size: 'default'
    }
});
const Button = /*#__PURE__*/ React__namespace.forwardRef((_param, ref)=>{
    var { className, variant, size, asChild = false } = _param, props = _object_without_properties_loose._(_param, [
        "className",
        "variant",
        "size",
        "asChild"
    ]);
    const Comp = asChild ? reactSlot.Slot : 'button';
    return /*#__PURE__*/ jsxRuntime.jsx(Comp, _extends._({
        className: cn(buttonVariants({
            variant,
            size,
            className
        })),
        ref: ref
    }, props));
});
Button.displayName = 'Button';

function ChatCanvasActions(props) {
    var _props_children;
    const children = (_props_children = props.children) != null ? _props_children : /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(ArtifactVersionHistory, {}),
            /*#__PURE__*/ jsxRuntime.jsx(ArtifactContentCopy, {}),
            /*#__PURE__*/ jsxRuntime.jsx(ArtifactDownloadButton, {}),
            /*#__PURE__*/ jsxRuntime.jsx(CanvasCloseButton, {})
        ]
    });
    return /*#__PURE__*/ jsxRuntime.jsx("div", {
        className: cn('flex items-center gap-1', props.className),
        children: children
    });
}
function ArtifactVersionHistory() {
    const { getArtifactsByType, openArtifactInCanvas, displayedArtifact, getArtifactVersion, restoreArtifact } = context12s.useChatCanvas();
    const [isOpen, setIsOpen] = React.useState(false);
    if (!displayedArtifact) return null;
    const allArtifactsByCurrentType = getArtifactsByType(displayedArtifact.type);
    return /*#__PURE__*/ jsxRuntime.jsxs(popover12s.Popover, {
        open: isOpen,
        onOpenChange: setIsOpen,
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(popover12s.PopoverTrigger, {
                asChild: true,
                children: /*#__PURE__*/ jsxRuntime.jsxs(Button, {
                    variant: "secondary",
                    className: "h-8 cursor-pointer rounded-full text-xs",
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(lucideReact.History, {
                            className: "mr-1 size-4"
                        }),
                        "Version ",
                        getArtifactVersion(displayedArtifact).versionNumber
                    ]
                })
            }),
            /*#__PURE__*/ jsxRuntime.jsxs(popover12s.PopoverContent, {
                className: "w-48 p-0 text-xs",
                align: "end",
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx("h4", {
                        className: "border-b p-2 px-3 font-semibold",
                        children: "Version History"
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx("div", {
                        className: "max-h-80 overflow-y-auto",
                        children: allArtifactsByCurrentType.map((artifact, index)=>{
                            const isCurrent = isEqualArtifact(artifact, displayedArtifact);
                            const { versionNumber, isLatest } = getArtifactVersion(artifact);
                            return /*#__PURE__*/ jsxRuntime.jsxs("div", {
                                className: "text-muted-foreground flex cursor-pointer items-center justify-between px-3 py-2 hover:bg-gray-100",
                                onClick: ()=>{
                                    openArtifactInCanvas(artifact);
                                    setIsOpen(false);
                                },
                                children: [
                                    /*#__PURE__*/ jsxRuntime.jsxs("span", {
                                        className: cn(isCurrent && 'text-blue-500'),
                                        children: [
                                            "Version ",
                                            versionNumber
                                        ]
                                    }),
                                    isLatest ? /*#__PURE__*/ jsxRuntime.jsx(badge12s.Badge, {
                                        className: "h-6 w-[70px] justify-center bg-blue-500 text-center hover:bg-blue-600",
                                        children: "Latest"
                                    }) : /*#__PURE__*/ jsxRuntime.jsx(Button, {
                                        variant: "outline",
                                        size: "sm",
                                        className: "h-6 w-[70px] shrink-0 cursor-pointer rounded-full text-xs",
                                        onClick: (e)=>{
                                            e.stopPropagation();
                                            restoreArtifact(artifact);
                                            setIsOpen(false);
                                        },
                                        children: "Restore"
                                    })
                                ]
                            }, index);
                        })
                    })
                ]
            })
        ]
    });
}
function ArtifactContentCopy() {
    const { isCopied, copyToClipboard } = useCopyToClipboard12s.useCopyToClipboard({
        timeout: 1000
    });
    const { displayedArtifact } = context12s.useChatCanvas();
    if (!displayedArtifact) return null;
    const content = getArtifactContent(displayedArtifact);
    if (!content) return null;
    const handleCopy = ()=>{
        if (isCopied) return;
        copyToClipboard(content);
    };
    return /*#__PURE__*/ jsxRuntime.jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: handleCopy,
        children: isCopied ? /*#__PURE__*/ jsxRuntime.jsx(lucideReact.Check, {
            className: "size-4"
        }) : /*#__PURE__*/ jsxRuntime.jsx(lucideReact.Copy, {
            className: "size-4"
        })
    });
}
function getArtifactContent(artifact) {
    if (artifact.type === 'code') {
        return artifact.data.code;
    }
    if (artifact.type === 'document') {
        return artifact.data.content;
    }
    return null;
}
function ArtifactDownloadButton() {
    const { displayedArtifact } = context12s.useChatCanvas();
    if (!displayedArtifact) return null;
    const content = getArtifactContent(displayedArtifact);
    const fileName = getArtifactDownloadFileName(displayedArtifact);
    if (!content || !fileName) return null;
    const handleDownload = ()=>{
        const blob = new Blob([
            content
        ], {
            type: 'text/plain'
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };
    return /*#__PURE__*/ jsxRuntime.jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: handleDownload,
        children: /*#__PURE__*/ jsxRuntime.jsx(lucideReact.Download, {
            className: "size-4"
        })
    });
}
function getArtifactDownloadFileName(artifact) {
    if (artifact.type === 'code') {
        return artifact.data.file_name;
    }
    if (artifact.type === 'document') {
        return artifact.data.title;
    }
    return null;
}
function CanvasCloseButton() {
    const { closeCanvas } = context12s.useChatCanvas();
    return /*#__PURE__*/ jsxRuntime.jsx(Button, {
        variant: "ghost",
        size: "icon",
        className: "cursor-pointer rounded-full",
        onClick: closeCanvas,
        children: /*#__PURE__*/ jsxRuntime.jsx(lucideReact.X, {
            className: "size-4"
        })
    });
}
ChatCanvasActions.History = ArtifactVersionHistory;
ChatCanvasActions.Copy = ArtifactContentCopy;
ChatCanvasActions.Download = ArtifactDownloadButton;
ChatCanvasActions.Close = CanvasCloseButton;

exports.Button = Button;
exports.ChatCanvasActions = ChatCanvasActions;
exports.MessageAnnotationType = MessageAnnotationType;
exports.cn = cn;
exports.extractArtifactsFromAllMessages = extractArtifactsFromAllMessages;
exports.extractArtifactsFromMessage = extractArtifactsFromMessage;
exports.getAnnotationData = getAnnotationData;
exports.getInlineAnnotations = getInlineAnnotations;
exports.isEqualArtifact = isEqualArtifact;
exports.isMessageAnnotation = isMessageAnnotation;
exports.parseInlineAnnotation = parseInlineAnnotation;
exports.toInlineAnnotation = toInlineAnnotation;
