import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { ComponentType } from 'react';
import { CitationComponentProps, LanguageRendererProps, DocumentFile } from '../widgets/index.js';

type MessageRole = 'system' | 'user' | 'assistant' | 'data';
type JSONValue = null | string | number | boolean | {
    [value: string]: JSONValue;
} | JSONValue[];
interface Message {
    content: string;
    role: MessageRole;
    annotations?: JSONValue[];
}
type ChatHandler = {
    input: string;
    setInput: (input: string) => void;
    isLoading: boolean;
    messages: Message[];
    reload?: (chatRequestOptions?: {
        data?: any;
    }) => void;
    stop?: () => void;
    append: (message: Message, chatRequestOptions?: {
        data?: any;
    }) => Promise<string | null | undefined>;
    setMessages?: (messages: (Message & {
        id: string;
    })[]) => void;
};
type ChatContext = ChatHandler & {
    requestData: any;
    setRequestData: (data: any) => void;
};

/**
 * Type for annotation parser functions
 */
type AnnotationParser = (message: Message) => unknown[];
/**
 * Gets all annotation data from a message by type, combining results from multiple parsers
 * @param message - The message to extract annotations from
 * @param type - The annotation type to filter by (can be standard or custom)
 * @param parsers - Array of parser functions to use (defaults to Vercel and inline parsers)
 * @returns Array of data from annotations of the specified type from all parsers
 */
declare function getAnnotationData<T = unknown>(message: Message, type: string, parsers?: AnnotationParser[]): T[];

declare enum MessageAnnotationType {
    IMAGE = "image",
    DOCUMENT_FILE = "document_file",
    SOURCES = "sources",
    EVENTS = "events",
    SUGGESTED_QUESTIONS = "suggested_questions",
    AGENT_EVENTS = "agent",
    ARTIFACT = "artifact"
}
type MessageAnnotation<T = unknown> = {
    type: string;
    data: T;
};
declare function isMessageAnnotation(annotation: unknown): annotation is MessageAnnotation;

declare function getInlineAnnotations(message: Message): unknown[];
declare function toInlineAnnotation(annotation: MessageAnnotation): string;
/**
 * Parses and validates an inline annotation from a code block
 * @param language - The language identifier from the markdown code block
 * @param codeValue - The raw code content from a markdown code block
 * @returns The parsed annotation if valid, null if not an annotation or invalid
 */
declare function parseInlineAnnotation(language: string, codeValue: string): MessageAnnotation | null;

declare function isEqualArtifact(a: Artifact, b: Artifact): boolean;
declare function extractArtifactsFromAllMessages(messages: Message[]): Artifact<unknown>[];
declare function extractArtifactsFromMessage(message: Message): Artifact[];
type CodeArtifactError = {
    artifact: CodeArtifact;
    errors: string[];
};
type Artifact<T = unknown> = {
    created_at: number;
    type: 'code' | 'document';
    data: T;
};
type CodeArtifact = Artifact<{
    file_name: string;
    code: string;
    language: string;
}>;
type DocumentArtifact = Artifact<{
    title: string;
    content: string;
    type: string;
    sources?: {
        id: string;
    }[];
}>;

interface ChatSectionProps extends React.PropsWithChildren {
    handler: ChatHandler;
    className?: string;
}
declare function ChatSection(props: ChatSectionProps): react_jsx_runtime.JSX.Element;

interface ChatCanvasActionsProps {
    children?: React.ReactNode;
    className?: string;
}
declare function ChatCanvasActions(props: ChatCanvasActionsProps): react_jsx_runtime.JSX.Element;
declare namespace ChatCanvasActions {
    var History: typeof ArtifactVersionHistory;
    var Copy: typeof ArtifactContentCopy;
    var Download: typeof ArtifactDownloadButton;
    var Close: typeof CanvasCloseButton;
}
declare function ArtifactVersionHistory(): react_jsx_runtime.JSX.Element | null;
declare function ArtifactContentCopy(): react_jsx_runtime.JSX.Element | null;
declare function ArtifactDownloadButton(): react_jsx_runtime.JSX.Element | null;
declare function CanvasCloseButton(): react_jsx_runtime.JSX.Element;

interface CodeArtifactViewerProps {
    className?: string;
    tabs?: Record<string, React.ReactNode>;
}
declare function CodeArtifactViewer({ className, tabs, }: CodeArtifactViewerProps): react_jsx_runtime.JSX.Element | null;

interface DocumentArtifactViewerProps {
    className?: string;
    children?: React.ReactNode;
}
declare function DocumentArtifactViewer({ className, children, }: DocumentArtifactViewerProps): react_jsx_runtime.JSX.Element | null;

declare function ArtifactCard({ data }: {
    data: Artifact;
}): react_jsx_runtime.JSX.Element;

interface ChatCanvasProps {
    children?: React.ReactNode;
    className?: string;
}
declare function ChatCanvas({ children, className }: ChatCanvasProps): react_jsx_runtime.JSX.Element | null;
declare namespace ChatCanvas {
    var CodeArtifact: typeof CodeArtifactViewer;
    var DocumentArtifact: typeof DocumentArtifactViewer;
    var Artifact: typeof ArtifactCard;
    var Actions: typeof ChatCanvasActions;
}

interface ChatInputProps extends React.PropsWithChildren {
    className?: string;
    resetUploadedFiles?: () => void;
    annotations?: any;
}
interface ChatInputFormProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatInputFieldProps {
    className?: string;
    placeholder?: string;
}
interface ChatInputUploadProps {
    className?: string;
    onUpload?: (file: File) => Promise<void> | undefined;
    allowedExtensions?: string[];
    multiple?: boolean;
}
interface ChatInputSubmitProps extends React.PropsWithChildren {
    className?: string;
    disabled?: boolean;
}
interface ChatInputContext {
    isDisabled: boolean;
    handleKeyDown: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void;
    handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
    isComposing: boolean;
    setIsComposing: (value: boolean) => void;
}
declare const useChatInput: () => ChatInputContext;
declare function ChatInput(props: ChatInputProps): react_jsx_runtime.JSX.Element;
declare namespace ChatInput {
    var Form: typeof ChatInputForm;
    var Field: typeof ChatInputField;
    var Upload: typeof ChatInputUpload;
    var Submit: typeof ChatInputSubmit;
}
declare function ChatInputForm(props: ChatInputFormProps): react_jsx_runtime.JSX.Element;
declare function ChatInputField(props: ChatInputFieldProps): react_jsx_runtime.JSX.Element;
declare function ChatInputUpload(props: ChatInputUploadProps): react_jsx_runtime.JSX.Element;
declare function ChatInputSubmit(props: ChatInputSubmitProps): react_jsx_runtime.JSX.Element;

interface ChatMessagesProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatMessagesListProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatMessagesLoadingProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatMessagesEmptyProps extends React.PropsWithChildren {
    className?: string;
    heading?: string;
    subheading?: string;
}
interface ChatActionsProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatMessagesContext {
    isPending: boolean;
    showReload?: boolean;
    showStop?: boolean;
    messageLength: number;
    lastMessage: Message;
}
declare const useChatMessages: () => ChatMessagesContext;
declare function ChatMessages(props: ChatMessagesProps): react_jsx_runtime.JSX.Element;
declare namespace ChatMessages {
    var List: typeof ChatMessagesList;
    var Loading: typeof ChatMessagesLoading;
    var Empty: typeof ChatMessagesEmpty;
    var Actions: typeof ChatActions;
}
declare function ChatMessagesList(props: ChatMessagesListProps): react_jsx_runtime.JSX.Element;
declare function ChatMessagesEmpty(props: ChatMessagesEmptyProps): react_jsx_runtime.JSX.Element | null;
declare function ChatMessagesLoading(props: ChatMessagesLoadingProps): react_jsx_runtime.JSX.Element | null;
declare function ChatActions(props: ChatActionsProps): react_jsx_runtime.JSX.Element | null;

declare function EventAnnotations(): react_jsx_runtime.JSX.Element | null;
declare function AgentEventAnnotations(): react_jsx_runtime.JSX.Element | null;
declare function ImageAnnotations(): react_jsx_runtime.JSX.Element | null;
declare function DocumentFileAnnotations(): react_jsx_runtime.JSX.Element | null;
declare function SourceAnnotations(): react_jsx_runtime.JSX.Element | null;
declare function SuggestedQuestionsAnnotations(): react_jsx_runtime.JSX.Element | null;

interface ChatMessageProps extends React.PropsWithChildren {
    message: Message;
    isLast: boolean;
    className?: string;
    isLoading?: boolean;
    append?: ChatHandler['append'];
}
interface ChatMessageAvatarProps extends React.PropsWithChildren {
    className?: string;
}
declare enum ContentPosition {
    TOP = -9999,
    CHAT_EVENTS = 0,
    AFTER_EVENTS = 1,
    CHAT_AGENT_EVENTS = 2,
    AFTER_AGENT_EVENTS = 3,
    CHAT_IMAGE = 4,
    AFTER_IMAGE = 5,
    BEFORE_MARKDOWN = 6,
    MARKDOWN = 7,
    AFTER_MARKDOWN = 8,
    CHAT_DOCUMENT_FILES = 9,
    AFTER_DOCUMENT_FILES = 10,
    CHAT_SOURCES = 11,
    AFTER_SOURCES = 12,
    SUGGESTED_QUESTIONS = 13,
    AFTER_SUGGESTED_QUESTIONS = 14,
    BOTTOM = 9999
}
interface ChatMessageContentProps extends React.PropsWithChildren {
    className?: string;
    isLoading?: boolean;
    append?: ChatHandler['append'];
    message?: Message;
}
interface ChatMessageActionsProps extends React.PropsWithChildren {
    className?: string;
}
interface ChatMarkdownProps extends React.PropsWithChildren {
    citationComponent?: ComponentType<CitationComponentProps>;
    className?: string;
    languageRenderers?: Record<string, ComponentType<LanguageRendererProps>>;
    annotationRenderers?: Record<string, ComponentType<{
        data: any;
    }>>;
}
declare function ChatMessage(props: ChatMessageProps): react_jsx_runtime.JSX.Element;
declare function ChatMessageAvatar(props: ChatMessageAvatarProps): react_jsx_runtime.JSX.Element | null;
declare function ChatMessageContent(props: ChatMessageContentProps): react_jsx_runtime.JSX.Element;
declare function ChatMarkdown(props: ChatMarkdownProps): react_jsx_runtime.JSX.Element;
declare function ChatMessageActions(props: ChatMessageActionsProps): react_jsx_runtime.JSX.Element | null;
type ComposibleChatMessageContent = typeof ChatMessageContent & {
    Event: typeof EventAnnotations;
    AgentEvent: typeof AgentEventAnnotations;
    Image: typeof ImageAnnotations;
    Markdown: typeof ChatMarkdown;
    DocumentFile: typeof DocumentFileAnnotations;
    Source: typeof SourceAnnotations;
    SuggestedQuestions: typeof SuggestedQuestionsAnnotations;
};
type ComposibleChatMessage = typeof ChatMessage & {
    Avatar: typeof ChatMessageAvatar;
    Content: ComposibleChatMessageContent;
    Actions: typeof ChatMessageActions;
};
declare const PrimiviteChatMessage: ComposibleChatMessage;

declare const defaultAnnotationRenderers: Record<string, ComponentType<{
    data: any;
}>>;

declare const useChatUI: () => ChatContext;

interface ChatCanvasContextType {
    allArtifacts: Artifact[];
    getArtifactsByType: (type: Artifact['type']) => Artifact[];
    displayedArtifact: Artifact | undefined;
    isCanvasOpen: boolean;
    openArtifactInCanvas: (artifact: Artifact) => void;
    closeCanvas: () => void;
    appendErrors: (artifact: CodeArtifact, errors: string[]) => void;
    clearCodeErrors: (artifact: CodeArtifact) => void;
    getCodeErrors: (artifact: CodeArtifact) => string[];
    fixCodeErrors: (artifact: CodeArtifact) => void;
    getArtifactVersion: (artifact: Artifact) => {
        versionNumber: number;
        isLatest: boolean;
    };
    restoreArtifact: (artifact: Artifact) => void;
    updateArtifact: (artifact: Artifact, content: string) => void;
}
declare function useChatCanvas(): ChatCanvasContextType;

interface ChatMessageContext {
    message: Message;
    isLast: boolean;
    isLoading?: boolean;
    append?: ChatHandler['append'];
}
declare const useChatMessage: () => ChatMessageContext;

declare function useFile({ uploadAPI }: {
    uploadAPI: string;
}): {
    imageUrl: string | null;
    setImageUrl: react.Dispatch<react.SetStateAction<string | null>>;
    files: DocumentFile[];
    removeDoc: (file: DocumentFile) => void;
    reset: () => void;
    getAnnotations: () => ({
        type: string;
        data: {
            url: string;
            files?: undefined;
        };
    } | {
        type: string;
        data: {
            files: DocumentFile[];
            url?: undefined;
        };
    })[];
    uploadFile: (file: File, requestParams?: any) => Promise<boolean | void>;
};

export { Artifact, ChatCanvas, ChatInput, PrimiviteChatMessage as ChatMessage, ChatMessages, ChatSection, CodeArtifact, ContentPosition, DocumentArtifact, MessageAnnotationType, defaultAnnotationRenderers, extractArtifactsFromAllMessages, extractArtifactsFromMessage, getAnnotationData, getInlineAnnotations, isEqualArtifact, isMessageAnnotation, parseInlineAnnotation, toInlineAnnotation, useChatCanvas, useChatInput, useChatMessage, useChatMessages, useChatUI, useFile };
export type { ChatContext, ChatHandler, CodeArtifactError, JSONValue, Message, MessageAnnotation };
