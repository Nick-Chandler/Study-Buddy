'use client';
import { _ } from '@swc/helpers/_/_extends';
import { jsx } from 'react/jsx-runtime';
import { createContext, useContext, useState, useMemo, useEffect } from 'react';
import { e as extractArtifactsFromAllMessages, a as extractArtifactsFromMessage, t as toInlineAnnotation, i as isEqualArtifact } from './actions-12s-M34siTXk.js';

const chatContext = createContext(null);
const ChatProvider = chatContext.Provider;
const useChatUI = ()=>{
    const context = useContext(chatContext);
    if (!context) {
        throw new Error('useChatUI must be used within a ChatProvider');
    }
    return context;
};

const ChatCanvasContext = /*#__PURE__*/ createContext(undefined);
function ChatCanvasProvider({ children }) {
    const { messages, isLoading, append, requestData, setMessages } = useChatUI();
    const [isCanvasOpen, setIsCanvasOpen] = useState(false) // whether the canvas is open
    ;
    const [displayedArtifact, setDisplayedArtifact] = useState() // the artifact currently displayed in the canvas
    ;
    const [codeErrors, setCodeErrors] = useState([]) // contain all errors when compiling with Babel and runtime
    ;
    const allArtifacts = useMemo(()=>extractArtifactsFromAllMessages(messages), [
        messages
    ]);
    // get all artifacts from the last message, this may not be the latest artifact in case last message doesn't have any artifact
    const artifactsFromLastMessage = useMemo(()=>{
        const lastMessage = messages[messages.length - 1];
        if (!lastMessage) return [];
        const artifacts = extractArtifactsFromMessage(lastMessage);
        return artifacts;
    }, [
        messages
    ]);
    useEffect(()=>{
        // when stream is loading and last message has a artifact, open the canvas with that artifact
        if (artifactsFromLastMessage.length > 0 && isLoading) {
            setIsCanvasOpen(true);
            setDisplayedArtifact(artifactsFromLastMessage[artifactsFromLastMessage.length - 1]);
        }
    }, [
        artifactsFromLastMessage,
        isCanvasOpen,
        isLoading
    ]);
    const openArtifactInCanvas = (artifact)=>{
        setDisplayedArtifact(artifact);
        setIsCanvasOpen(true);
    };
    const getArtifactsByType = (type)=>{
        return allArtifacts.filter((a)=>a.type === type);
    };
    const getArtifactVersion = (artifact)=>{
        const allArtifactsByCurrentType = getArtifactsByType(artifact.type);
        const versionNumber = allArtifactsByCurrentType.findIndex((a)=>isEqualArtifact(a, artifact)) + 1;
        return {
            versionNumber,
            isLatest: versionNumber === allArtifactsByCurrentType.length
        };
    };
    const restoreArtifact = (artifact)=>{
        if (!setMessages) return;
        const newArtifact = _({}, artifact, {
            created_at: Date.now()
        });
        const newMessages = [
            ...messages,
            {
                id: `restore-msg-${Date.now()}`,
                role: 'user',
                content: `Restore to ${artifact.type} version ${getArtifactVersion(artifact).versionNumber}`
            },
            {
                id: `restore-success-${Date.now()}`,
                role: 'assistant',
                content: `Successfully restored to ${artifact.type} version ${getArtifactVersion(artifact).versionNumber}\n${toInlineAnnotation({
                    type: 'artifact',
                    data: newArtifact
                })}`
            }
        ];
        setMessages(newMessages);
        openArtifactInCanvas(newArtifact);
    };
    const updateArtifact = (artifact, content)=>{
        if (!setMessages) return;
        let newArtifact;
        if (artifact.type === 'code') {
            const codeArtifact = artifact;
            newArtifact = {
                created_at: Date.now(),
                type: 'code',
                data: {
                    code: content,
                    file_name: codeArtifact.data.file_name,
                    language: codeArtifact.data.language
                }
            };
        } else if (artifact.type === 'document') {
            const documentArtifact = artifact;
            newArtifact = {
                created_at: Date.now(),
                type: 'document',
                data: {
                    content,
                    title: documentArtifact.data.title,
                    type: documentArtifact.data.type,
                    sources: documentArtifact.data.sources
                }
            };
        }
        if (!newArtifact) return;
        const newMessages = [
            ...messages,
            {
                role: 'user',
                content: `Update content for ${artifact.type} artifact version ${getArtifactVersion(artifact).versionNumber}`
            },
            {
                role: 'assistant',
                content: `Updated content for ${artifact.type} artifact version ${getArtifactVersion(artifact).versionNumber}\n${toInlineAnnotation({
                    type: 'artifact',
                    data: newArtifact
                })}`
            }
        ];
        setMessages(newMessages);
        openArtifactInCanvas(newArtifact);
    };
    const closeCanvas = ()=>{
        setIsCanvasOpen(false);
        setDisplayedArtifact(undefined);
    };
    const appendErrors = (artifact, errors)=>{
        setIsCanvasOpen(true);
        setCodeErrors((prev)=>[
                ...prev,
                {
                    artifact,
                    errors
                }
            ]);
    };
    const clearCodeErrors = (artifact)=>{
        setCodeErrors((prev)=>prev.filter((error)=>!isEqualArtifact(error.artifact, artifact)));
    };
    const getCodeErrors = (artifact)=>{
        const artifactErrors = codeErrors.find((error)=>isEqualArtifact(error.artifact, artifact));
        var _artifactErrors_errors;
        const uniqueErrors = Array.from(new Set((_artifactErrors_errors = artifactErrors == null ? void 0 : artifactErrors.errors) != null ? _artifactErrors_errors : []));
        return uniqueErrors;
    };
    const fixCodeErrors = (artifact)=>{
        const errors = getCodeErrors(artifact);
        if (errors.length === 0) return;
        append({
            role: 'user',
            content: `Please fix the following errors: ${errors.join('\n')} happened when running the code.`
        }, {
            data: requestData
        });
    };
    return /*#__PURE__*/ jsx(ChatCanvasContext.Provider, {
        value: {
            allArtifacts,
            getArtifactsByType,
            displayedArtifact,
            isCanvasOpen,
            openArtifactInCanvas,
            closeCanvas,
            appendErrors,
            clearCodeErrors,
            getCodeErrors,
            fixCodeErrors,
            getArtifactVersion,
            restoreArtifact,
            updateArtifact
        },
        children: children
    });
}
function useChatCanvas() {
    const context = useContext(ChatCanvasContext);
    if (context === undefined) {
        throw new Error('useChatCanvas must be used within a ChatCanvasProvider');
    }
    return context;
}

export { ChatProvider as C, useChatUI as a, ChatCanvasProvider as b, useChatCanvas as u };
